{
  "quizzes": {

    "IOT321": [
      {
        "chapter": "chapter 1",
        "question": "What is an embedded system?",
        "options": [
          "A server running cloud apps",
          "A combination of hardware and software for a specific function",
          "A gaming console",
          "A regular laptop"
        ],
        "answer_index": 1,
        "explanation": "An embedded system is designed to perform a dedicated function within a larger mechanical or electrical system. Unlike a general-purpose computer (like a laptop), it's a specialized combination of computer hardware and software for a specific task, such as the system inside a microwave oven."
      },
      {
        "chapter": "chapter 1",
        "question": "Which of the following is an example of an embedded system?",
        "options": [
          "Desktop PC",
          "Microwave oven",
          "Gaming laptop",
          "Cloud server"
        ],
        "answer_index": 1,
        "explanation": "A microwave oven contains a computer system dedicated solely to controlling its functions (heating, timer, etc.). A Desktop PC, gaming laptop, and cloud server are all general-purpose computers designed to run a wide variety of applications."
      },
      {
        "chapter": "chapter 1",
        "question": "What distinguishes an embedded system from a general-purpose computer?",
        "options": [
          "Embedded systems are faster",
          "Embedded systems perform one task efficiently",
          "Embedded systems run multiple programs",
          "Embedded systems have higher memory"
        ],
        "answer_index": 1,
        "explanation": "The key difference is specialization. An embedded system is optimized to perform a specific task or a small set of tasks very efficiently and reliably, whereas a general-purpose computer is designed to be flexible and run many different types of software."
      },
      {
        "chapter": "chapter 1",
        "question": "Why are processors often used instead of custom hardware in embedded systems?",
        "options": [
          "Less flexible",
          "Cheaper and allows software updates",
          "Consumes more power",
          "Occupies more space"
        ],
        "answer_index": 1,
        "explanation": "Using a general-purpose processor is often more cost-effective for manufacturing at scale. It also provides immense flexibility, as the system's logic can be changed or updated via software without redesigning the hardware."
      },
      {
        "chapter": "chapter 1",
        "question": "What is a real-time system?",
        "options": [
          "A system that stores large data",
          "A system with strict timing constraints",
          "A system focused on internet speed",
          "A system with cloud backup"
        ],
        "answer_index": 1,
        "explanation": "A real-time system is a computing system where the correctness of a result depends not only on the logical result of the computation but also on the time at which the results are produced. They must meet strict deadlines."
      },
      {
        "chapter": "chapter 1",
        "question": "What happens if a deadline is missed in a hard real-time system?",
        "options": [
          "Slight delay",
          "Warning message",
          "Catastrophic failure",
          "Automatic reboot"
        ],
        "answer_index": 2,
        "explanation": "In a 'hard' real-time system, missing a deadline is considered a total system failure. Examples include anti-lock braking systems or airbag controllers in a car, where a delay of even milliseconds can have catastrophic consequences."
      },
      {
        "chapter": "chapter 1",
        "question": "What is polling in embedded systems?",
        "options": [
          "A method where CPU waits for user input",
          "A method where the processor repeatedly checks device status",
          "An algorithm for memory optimization",
          "A networking protocol"
        ],
        "answer_index": 1,
        "explanation": "Polling is a technique in which the processor continuously checks the status of a peripheral in a loop to determine if it needs service. It’s simple but inefficient, as it wastes CPU cycles."
      },
      {
        "chapter": "chapter 1",
        "question": "What is an interrupt in embedded systems?",
        "options": [
          "A mechanism to stop hardware permanently",
          "A signal that temporarily halts the CPU to handle a specific task",
          "A command to restart the device",
          "A loop that checks device status"
        ],
        "answer_index": 1,
        "explanation": "An interrupt is a hardware or software signal that causes the processor to temporarily stop its current task and execute an interrupt service routine (ISR). It allows efficient event-driven processing."
      },
      {
        "chapter": "chapter 1",
        "question": "Which memory type stores permanent firmware in embedded systems?",
        "options": [
          "RAM",
          "ROM",
          "Cache",
          "Flash buffer"
        ],
        "answer_index": 1,
        "explanation": "ROM (Read-Only Memory) stores the embedded software (firmware) that runs permanently on the device, even when it’s powered off."
      },
      {
        "chapter": "chapter 1",
        "question": "Why do embedded systems vary greatly in hardware design?",
        "options": [
          "To improve portability",
          "Because each system is optimized for its specific function",
          "Due to lack of standards",
          "To increase software compatibility"
        ],
        "answer_index": 1,
        "explanation": "Each embedded system is designed for a specific application. Designers remove unnecessary components to reduce cost and power consumption."
      },
      {
        "chapter": "chapter 1",
        "question": "What are the main input and output types in embedded systems?",
        "options": [
          "Input: sensors, Output: displays or actuators",
          "Input: hard drives, Output: printers",
          "Input: keyboards only, Output: monitors only",
          "Input: APIs, Output: databases"
        ],
        "answer_index": 0,
        "explanation": "Inputs in embedded systems include sensors, buttons, and signals, while outputs control displays, actuators, or other devices interacting with the physical world."
      },
      {
        "chapter": "chapter 1",
        "question": "What is the role of an RTOS in embedded software?",
        "options": [
          "It handles user interfaces",
          "It manages tasks and improves responsiveness",
          "It increases system clock speed",
          "It stores application data"
        ],
        "answer_index": 1,
        "explanation": "A Real-Time Operating System (RTOS) organizes software into tasks, ensuring that high-priority tasks execute in time and improving the overall responsiveness of the embedded system."
      },
      {
        "chapter": "chapter 1",
        "question": "What is MIPS a measure of?",
        "options": [
          "Power usage",
          "Processing speed",
          "Storage capacity",
          "Temperature range"
        ],
        "answer_index": 1,
        "explanation": "MIPS stands for Millions of Instructions Per Second. It measures a processor’s computational performance."
      },
      {
        "chapter": "chapter 1",
        "question": "Why is power consumption important in embedded systems?",
        "options": [
          "It affects display brightness",
          "It determines battery life and heat generation",
          "It controls data transmission rate",
          "It has no impact on small devices"
        ],
        "answer_index": 1,
        "explanation": "Power efficiency is critical for portable or battery-powered devices. Lower power usage means smaller batteries, less heat, and longer operation time."
      },
      {
        "chapter": "chapter 1",
        "question": "Why is C language preferred for embedded programming?",
        "options": [
          "Because it is object-oriented",
          "Because it provides both low-level hardware access and high-level abstraction",
          "Because it runs only on 64-bit processors",
          "Because it is easier than Assembly"
        ],
        "answer_index": 1,
        "explanation": "C offers direct hardware control with structured programming features. It produces compact and efficient code suitable for embedded systems."
      },
      {
        "chapter": "chapter 1",
        "question": "Which of the following languages is mainly used for safety-critical systems like aerospace?",
        "options": [
          "C",
          "Assembly",
          "Ada",
          "Forth"
        ],
        "answer_index": 2,
        "explanation": "Ada is used in safety-critical domains such as defense and aerospace due to its strong type-checking and structured design features."
      },
      {
        "chapter": "chapter 1",
        "question": "Why are fixed-width integers important in embedded systems?",
        "options": [
          "They make code faster",
          "They ensure consistent integer size across compilers and processors",
          "They increase clock speed",
          "They allow automatic debugging"
        ],
        "answer_index": 1,
        "explanation": "Fixed-width integers (like int8_t, int16_t) ensure that variables have predictable sizes across different architectures, improving portability and reliability."
      },
      {
        "chapter": "chapter 1",
        "question": "What does NRE stand for in embedded system design?",
        "options": [
          "Nonrecurring Engineering",
          "Network Resource Efficiency",
          "Normal Runtime Execution",
          "Non-Reduced Energy"
        ],
        "answer_index": 0,
        "explanation": "NRE (Nonrecurring Engineering) refers to one-time costs for designing and developing hardware and software before production begins."
      },
      {
        "chapter": "chapter 1",
        "question": "What is a key challenge for embedded developers when writing code?",
        "options": [
          "Handling abundant resources",
          "Working with limited memory and CPU power",
          "Accessing cloud APIs",
          "Managing multiple users"
        ],
        "answer_index": 1,
        "explanation": "Embedded developers must write efficient and compact code since embedded systems often have limited memory and processing power."
      },
      {
        "chapter": "chapter 1",
        "question": "What is dynamic memory fragmentation?",
        "options": [
          "Reorganizing files in ROM",
          "Uneven allocation of memory blocks leading to crashes",
          "A method for speeding up data access",
          "A type of power optimization"
        ],
        "answer_index": 1,
        "explanation": "Dynamic allocation can fragment memory over time, leaving unusable gaps and causing instability or crashes in long-running embedded systems."
      },
      {
    "chapter": "Chapter 6",
    "question": "What are the two main types of Random Access Memory (RAM) mentioned in the presentation?",
    "options": [
      "SRAM and DRAM",
      "ROM and EPROM",
      "Flash and EEPROM",
      "NVRAM and Masked ROM"
    ],
    "answer_index": 0,
    "explanation": "The presentation slide explicitly states that the two main types of RAM are SRAM (Static RAM) and DRAM (Dynamic RAM). ROM, EPROM, Flash, and EEPROM are all forms of Read-Only Memory."
  },
  {
    "chapter": "Chapter 6",
    "question": "Which type of memory needs a controller to perform constant refresh operations to keep data alive, even when powered?",
    "options": [
      "SRAM",
      "DRAM",
      "Masked ROM",
      "Flash Memory"
    ],
    "answer_index": 1,
    "explanation": "DRAM (Dynamic RAM) loses its data very quickly (4 times a second) even with power, so it requires a DRAM controller to constantly refresh it. SRAM retains data as long as power is on without refreshing."
  },
  {
    "chapter": "Chapter 6",
    "question": "Why is SRAM typically used for critical speed-sensitive tasks instead of main system memory?",
    "options": [
      "It is non-volatile.",
      "It has a lower cost-per-byte.",
      "It is much faster than DRAM and more expensive.",
      "It requires a DRAM controller."
    ],
    "answer_index": 2,
    "explanation": "SRAM is about 4 times faster than DRAM but is also more expensive to produce. This makes it ideal for speed-critical applications like CPU caches, while DRAM is used for larger, cheaper main memory."
  },
  {
    "chapter": "Chapter 6",
    "question": "Which type of ROM is programmed during manufacturing and cannot be changed afterward, making it cost-effective only for mass production?",
    "options": [
      "PROM (Programmable ROM)",
      "EPROM (Erasable and Programmable ROM)",
      "Masked ROM",
      "EEPROM (Electrically Erasable Programmable ROM)"
    ],
    "answer_index": 2,
    "explanation": "Masked ROM is preprogrammed with hardwired transistors during the manufacturing process. No changes can be made after it leaves the factory, so it is only cost-effective for stable, finalized code in large volumes (100,000+ units)."
  },
  {
    "chapter": "Chapter 6",
    "question": "How is an EPROM (Erasable and Programmable ROM) erased?",
    "options": [
      "Electrically, one byte at a time",
      "By exposure to ultraviolet (UV) light",
      "It cannot be erased",
      "By a DRAM controller"
    ],
    "answer_index": 1,
    "explanation": "EPROM is designed to be rewritable, but it must be erased by exposing the chip to UV light, which is a slow process. This is different from EEPROM, which is erased electrically."
  },
  {
    "chapter": "Chapter 6",
    "question": "What is a key difference between Flash memory and EEPROM regarding erasure?",
    "options": [
      "Flash is erased with UV light, while EEPROM is electrical.",
      "Flash can be erased byte-by-byte, while EEPROM is sector-based.",
      "EEPROM can be erased byte-by-byte, while Flash is erased in sectors (blocks).",
      "EEPROM has unlimited write cycles, while Flash does not."
    ],
    "answer_index": 2,
    "explanation": "A key feature of EEPROM is its ability to be erased or rewritten at the byte level. Flash memory, while also electrical, must be erased in larger 'sectors' or 'blocks' (e.g., 8KB-64KB)."
  },
  {
    "chapter": "Chapter 6",
    "question": "What is NVRAM?",
    "options": [
      "Another name for Flash memory.",
      "SRAM that is combined with a battery backup to preserve data when power is off.",
      "DRAM that has a built-in refresh controller.",
      "A type of ROM that can be written to once."
    ],
    "answer_index": 1,
    "explanation": "NVRAM stands for Nonvolatile RAM. It consists of standard SRAM paired with a battery. When main power is on, it acts like normal SRAM, and when power is off, the battery preserves the data, making it non-volatile."
  },
  {
    "chapter": "Chapter 6",
    "question": "What is the primary benefit of using Direct Memory Access (DMA)?",
    "options": [
      "It makes the CPU run at a higher clock speed.",
      "It validates the integrity of memory using a checksum.",
      "It allows data transfers between devices and memory without CPU involvement, freeing the CPU.",
      "It erases Flash memory sectors automatically."
    ],
    "answer_index": 2,
    "explanation": "DMA is a technique that offloads data transfer tasks from the CPU. Instead of the CPU manually moving each byte, a DMA controller handles the transfer directly, which frees up the CPU to perform other processing tasks."
  },
  {
    "chapter": "Chapter 6",
    "question": "What is 'Endianness'?",
    "options": [
      "The order in which memory tests must be run.",
      "How multibyte data (like an integer) is stored in memory.",
      "The process of erasing an EPROM chip.",
      "The number of write cycles a Flash chip can endure."
    ],
    "answer_index": 1,
    "explanation": "Endianness defines how multibyte data is stored in memory. The two types are Big-endian (Most Significant Byte stored first at the lowest address) and Little-endian (Least Significant Byte stored first at the lowest address)."
  },
  {
    "chapter": "Chapter 6",
    "question": "If the 4-byte value 0x11223344 is stored in a **big-endian** system starting at address 0x1000, what value is stored at address 0x1001?",
    "options": [
      "0x11",
      "0x22",
      "0x33",
      "0x44"
    ],
    "answer_index": 1,
    "explanation": "Big-endian stores the Most Significant Byte (MSB) at the lowest memory address. For the value 0x11223344, the MSB is 0x11. So, 0x11 is at address 0x1000, 0x22 is at address 0x1001, 0x33 is at 0x1002, and 0x44 is at 0x1003."
  },
  {
    "chapter": "Chapter 6",
    "question": "TCP/IP protocols use 'network byte order'. What endianness is this?",
    "options": [
      "Little-endian",
      "Big-endian",
      "It depends on the host system.",
      "It is bi-endian and switches automatically."
    ],
    "answer_index": 1,
    "explanation": "The TCP/IP networking standard explicitly uses big-endian, which is referred to as 'network byte order'. Little-endian systems (like x86 processors) must convert their data to big-endian before sending it over the network."
  },
  {
    "chapter": "Chapter 6",
    "question": "What is the C macro `ntohl()` used for?",
    "options": [
      "Converting a 'long' (32-bit) value from Network to Host byte order.",
      "Converting a 'short' (16-bit) value from Host to Network byte order.",
      "Converting a 'long' (32-bit) value from Host to Network byte order.",
      "Halting the CPU for a network operation."
    ],
    "answer_index": 0,
    "explanation": "The macro `ntohl()` stands for 'Network to Host (Long)'. It is used to convert a 32-bit value from the network's big-endian format to the host system's native byte order. `htonl()` does the opposite (Host to Network)."
  },
  {
    "chapter": "Chapter 6",
    "question": "According to the presentation, what are the 'real culprits' of memory problems, which are more common than faulty chips?",
    "options": [
      "Power surges and physical damage.",
      "CPU overheating.",
      "Circuit board issues, such as wiring faults, missing chips, or improper insertion.",
      "Incorrect use of `htons()` and `ntohs()`."
    ],
    "answer_index": 2,
    "explanation": "The presentation states it's a misconception that faulty chips are the main problem, as they are rigorously pre-tested. The 'real culprits' are circuit board defects like wiring errors (broken/misrouted lines), missing chips, or improperly seated chips."
  },
  {
    "chapter": "Chapter 6",
    "question": "What is the correct and recommended order for executing the three main memory tests?",
    "options": [
      "1. Device test, 2. Address bus test, 3. Data bus test",
      "1. Address bus test, 2. Data bus test, 3. Device test",
      "1. Data bus test, 2. Device test, 3. Address bus test",
      "1. Data bus test, 2. Address bus test, 3. Device test"
    ],
    "answer_index": 3,
    "explanation": "The recommended strategy is to run the tests in order: Data bus test, Address bus test, and finally Device test. This is because the tests build on each other; for example, you cannot trust the address bus test if the data bus isn't working correctly."
  },
  {
    "chapter": "Chapter 6",
    "question": "The 'Walking 1's' test is an efficient method for testing what?",
    "options": [
      "The wiring of the data bus.",
      "The wiring of the address bus.",
      "The presence of a memory chip.",
      "The speed of the DMA controller."
    ],
    "answer_index": 0,
    "explanation": "The 'Walking 1's' test is used to check the wiring of the data bus. It writes patterns with a single '1' bit (e.g., 0001, 0010, 0100...) to a fixed address to ensure each data bit can be set independently and is not shorted or open."
  },
  {
    "chapter": "Chapter 6",
    "question": "What is the primary symptom of an address bus fault?",
    "options": [
      "Data bits are 'stuck' at 0 or 1.",
      "The CPU cache stops working.",
      "Overlapping addresses, where writing to one location overwrites data in another.",
      "The memory chip physically overheats."
    ],
    "answer_index": 2,
    "explanation": "Address signal faults, like a short or open wire, cause incorrect address decoding. This leads to 'overlapping addresses,' where two different addresses point to the same physical location, causing data written to one to overwrite the other. Stuck bits are a symptom of data signal faults."
  },
  {
    "chapter": "Chapter 6",
    "question": "Why is it important to disable the data cache when testing RAM?",
    "options": [
      "The cache is too slow and will interfere with the test.",
      "The cache may 'fake' memory success by responding to reads/writes instead of the RAM.",
      "The cache uses a different endianness, corrupting the test.",
      "The cache controller will conflict with the DMA controller."
    ],
    "answer_index": 1,
    "explanation": "If the data cache is enabled, it can 'fake' a successful memory test. Writes might only go to the cache and not to the physical RAM, and reads might be served from the cache. This means the test would be checking the cache, not the RAM itself. Therefore, the data cache must always be disabled."
  },
  {
    "chapter": "Chapter 6",
    "question": "Why is a simple checksum (summing all bytes) considered weaker than a CRC for validating ROM contents?",
    "options": [
      "It is much slower to calculate.",
      "It cannot be stored in ROM.",
      "It may miss multiple bit-flip errors that cancel each other out.",
      "It only works on RAM, not ROM."
    ],
    "answer_index": 2,
    "explanation": "A simple checksum's main weakness is that it can fail to detect certain errors. For example, if one bit flips from 1 to 0 and another flips from 0 to 1, the errors can 'cancel out' in the final sum, leading to a false pass. A CRC (Cyclic Redundancy Check) is a more robust algorithm designed to catch such common data errors."
  },
  {
    "chapter": "Chapter 6",
    "question": "What is a robust method to handle a potential power failure during an in-field flash memory update?",
    "options": [
      "Running the update code from the same flash sector being erased.",
      "Using a protected bootloader to verify flash integrity (with a CRC/checksum) on boot.",
      "Telling the user not to unplug the device.",
      "Encrypting the firmware image so it can't be corrupted."
    ],
    "answer_index": 1,
    "explanation": "A power failure during an update can corrupt the flash. A robust solution is to use a protected bootloader that runs first. This bootloader verifies the integrity of the main firmware using a CRC or checksum. If it's corrupt, the bootloader can enter a safe mode to allow a new update, or boot from a second 'backup' image."
  },
  {
    "chapter": "Chapter 6",
    "question": "What is a key difference between reading from and writing to Flash memory from a programmer's perspective?",
    "options": [
      "Reading is slow and complex, while writing is fast and simple.",
      "Reading requires a prior 'sector erase', while writing does not.",
      "Reading is fast and simple (like regular memory), while writing is slow and requires a prior sector-based erase.",
      "Reading is done byte-by-byte, while writing is done with DMA."
    ],
    "answer_index": 2,
    "explanation": "Reading from flash is fast, direct, and simple, acting like regular memory. Writing is complex: it is slow, and data cannot be written until the corresponding sector has first been erased. This erasure is done on a large sector-by-sector basis, not byte-by-byte."
  }],
  "IOT 453": [
      {
        "chapter": "Chapter 1",
        "question": "What is a major physical difference between the Arduino MEGA 2560 and the Arduino Uno?",
        "options": [
          "The Uno is larger and has more pins.",
          "The MEGA 2560 is larger and has more pins.",
          "They are identical in size.",
          "The Uno has a surface mount microcontroller, while the MEGA 2560 does not."
        ],
        "answer_index": 1,
        "explanation": "The Arduino MEGA 2560 is physically larger than the Uno and serves as an extension of its capabilities, offering a total of 86 socket connection points (pins) compared to the Uno's 32."
      },
      {
        "chapter": "Chapter 1",
        "question": "What is the part number of the main microcontroller on the Arduino MEGA 2560 board?",
        "options": [
          "ATmega328P",
          "ATmega16U2",
          "ATmega2560",
          "FT232RL"
        ],
        "answer_index": 2,
        "explanation": "The board gets its name from its main microcontroller, the ATmega2560. The ATmega16U2 is a separate chip used as a USB bridge."
      },
      {
        "chapter": "Chapter 1",
        "question": "What is the recommended voltage range for an external DC power supply connected to the Arduino MEGA 2560's power jack?",
        "options": [
          "5V only",
          "3.3V to 5V",
          "7V to 12V",
          "12V to 24V"
        ],
        "answer_index": 2,
        "explanation": "The Arduino MEGA 2560 can be run stand-alone by applying external DC power with a voltage between 7V and 12V to the external power connector."
      },
      {
        "chapter": "Chapter 1",
        "question": "The 'L' LED on the Arduino MEGA 2560 is a user-programmable LED connected to which digital pin?",
        "options": [
          "Digital pin 1",
          "Digital pin 13",
          "The 'ON' pin",
          "Digital pin 0 (RX)"
        ],
        "answer_index": 1,
        "explanation": "The L LED is a user-programmable LED connected to digital pin 13. It can be switched on and off by controlling this pin in a user sketch."
      },
      {
        "chapter": "Chapter 1",
        "question": "What is the function of the ATmega16U2 microcontroller on the Arduino MEGA 2560?",
        "options": [
          "It is the main processor for running sketches.",
          "It controls the 3.3V power regulation.",
          "It stores the bootloader.",
          "It acts as a bridge between the USB connection and the main microcontroller."
        ],
        "answer_index": 3,
        "explanation": "The ATmega16U2, found near the USB connector, acts as a bridge for programming the main microcontroller or for serial data communication between a computer and a user sketch."
      },
      {
        "chapter": "Chapter 1",
        "question": "What does ICSP stand for?",
        "options": [
          "In-Circuit System Protocol",
          "Internal Chip SPI Protocol",
          "In-Circuit Serial Programming",
          "Integrated Circuit Shield Port"
        ],
        "answer_index": 2,
        "explanation": "ICSP stands for In-Circuit Serial Programming. The header allows for alternative programming methods, such as using an external programmer, which can bypass the bootloader."
      },
      {
        "chapter": "Chapter 1",
        "question": "In the Arduino IDE, what is a user-written program called?",
        "options": [
          "A Script",
          "A Program",
          "A Sketch",
          "A File"
        ],
        "answer_index": 2,
        "explanation": "User-written programs that are typed into the Arduino IDE are known as sketches."
      },
      {
        "chapter": "Chapter 1",
        "question": "What are the add-on boards called that plug into the header sockets of the Arduino MEGA 2560 to extend its hardware?",
        "options": [
          "Modules",
          "Shields",
          "Hats",
          "Proto-boards"
        ],
        "answer_index": 1,
        "explanation": "External add-on boards called shields plug into the header sockets to extend the hardware functionality, offering features like Ethernet, WiFi, or motor control."
      },
      {
        "chapter": "Chapter 1",
        "question": "Arduino hardware is 'open-source.' What does this mean?",
        "options": [
          "The hardware is free.",
          "The hardware only works with open-source software.",
          "The design files are available for anyone to examine and modify.",
          "The hardware has no warranty."
        ],
        "answer_index": 2,
        "explanation": "Arduino boards are open-source hardware, which means the design files are available to be examined and modified by anyone under a Creative Commons license."
      },
      {
        "chapter": "Chapter 1",
        "question": "What is a major difference between the Arduino MEGA 2560 and the Arduino DUE, even though they have the same form factor?",
        "options": [
          "The MEGA 2560 operates at 5V (8-bit AVR), while the DUE operates at 3.3V (32-bit ARM).",
          "The DUE is an older, retired version of the MEGA 2560.",
          "The MEGA 2560 has two micro USB connectors, while the DUE has one type B.",
          "There is no difference; Genuino is just another name for DUE."
        ],
        "answer_index": 0,
        "explanation": "The two boards are not to be confused. The MEGA 2560 is a 5V board using an 8-bit AVR microcontroller, whereas the Arduino DUE is a 3.3V board using a 32-bit ARM microcontroller."
      },
      {
        "chapter": "Chapter 1",
        "question": "What is the purpose of the bootloader firmware on the main microcontroller?",
        "options": [
          "It manages the USB connection.",
          "It controls the 'L' LED.",
          "It allows the Arduino IDE to upload a new sketch to memory.",
          "It erases the EEPROM on startup."
        ],
        "answer_index": 2,
        "explanation": "The bootloader is the first code that runs on power-up. It waits for a short time to see if the Arduino IDE is trying to upload a new sketch; if not, it runs the sketch currently in memory."
      },
      {
        "chapter": "Chapter 1",
        "question": "What is ESD, and why is it a concern when handling an Arduino?",
        "options": [
          "External Short-circuit Damage; it happens when power is connected incorrectly.",
          "Electrostatic Discharge; it can damage the circuit board components.",
          "Electronic Software Debugging; it is a method for testing the board.",
          "Error-Safe Data; it refers to memory protection."
        ],
        "answer_index": 1,
        "explanation": "ESD stands for Electrostatic discharge. Static electricity stored in the human body can discharge into the circuit board when touched, potentially damaging the sensitive electronic components like the microcontroller."
      },
      {
        "chapter": "Chapter 1",
        "question": "The Arduino MEGA 2560 operates at 5V. What precaution must be taken when connecting 3.3V devices?",
        "options": [
          "None, 3.3V devices work fine with 5V pins.",
          "The 3.3V device must be connected to the Vin pin.",
          "The 3.3V device must be connected to the 5V pin, but only briefly.",
          "Voltage level shifters must be used to interface the pins."
        ],
        "answer_index": 3,
        "explanation": "Applying 5V to a 3.3V device can damage it. To interface a 3.3V device, it must use the 3.3V power pin and appropriate voltage level shifters on its I/O pins."
      },
      {
        "chapter": "Chapter 1",
        "question": "What component is *always* required when connecting an LED to an Arduino digital pin (except for the onboard 'L' LED)?",
        "options": [
          "A capacitor",
          "A transistor",
          "A series resistor",
          "A diode"
        ],
        "answer_index": 2,
        "explanation": "A resistor must always be used in series with an LED to limit the current drawn from the Arduino pin. Failure to do so can damage both the LED and the Arduino microcontroller."
      },
      {
        "chapter": "Chapter 1",
        "question": "What was a notable difference between the Arduino MEGA 2560 R3 (Revision 3) and previous revisions?",
        "options": [
          "The USB bridge chip was upgraded from ATmega8U2 to ATmega16U2.",
          "The operating voltage was changed from 3.3V to 5V.",
          "The main microcontroller was changed to an ATmega328P.",
          "The 'L' LED was removed."
        ],
        "answer_index": 0,
        "explanation": "A key difference in the R3 board was the upgrade of the USB to serial bridge microcontroller from an ATmega8U2 (with 8K Flash) to an ATmega16U2 (with 16K Flash)."
      },
      {
        "chapter": "Chapter 1",
        "question": "On newer Arduino MEGA 2560 REV3 boards (Rev3e), where is the reset button located?",
        "options": [
          "Next to the main ICSP header.",
          "On the bottom of the board.",
          "Next to the external power jack.",
          "Next to the USB connector."
        ],
        "answer_index": 3,
        "explanation": "On older REV3 boards, the reset switch was next to the main ICSP header. On newer Rev3e boards, it was moved to the corner next to the USB connector, making it accessible even with a shield attached."
      },
      {
        "chapter": "Chapter 1",
        "question": "When you plug an Arduino MEGA 2560 into a Windows 10 computer for the first time, how does it appear in the Device Manager?",
        "options": [
          "As an external hard drive.",
          "As a 'Ports (COM & LPT)' device, e.g., 'USB Serial Device (COM4)'.",
          "As a Human Interface Device.",
          "It does not appear in Device Manager."
        ],
        "answer_index": 1,
        "explanation": "After drivers are loaded, the Arduino should appear in the Windows Device Manager under the 'Ports (COM & LPT)' section as a 'USB Serial Device' with an assigned COM port number."
      },
      {
        "chapter": "Chapter 1",
        "question": "What sketch is factory loaded on a new official Arduino MEGA 2560 board?",
        "options": [
          "The ASCIITable sketch.",
          "A blank sketch (no code).",
          "The Blink sketch, which flashes the 'L' LED.",
          "The SerialEvent sketch."
        ],
        "answer_index": 2,
        "explanation": "A new official board comes with the Blink sketch factory loaded, which flashes the 'L' LED on and off every 1 second. This serves as a test and indicator that the board is working."
      },
      {
        "chapter": "Chapter 1",
        "question": "Before uploading a sketch from the Arduino IDE, which three settings must be correctly selected under the 'Tools' menu?",
        "options": [
          "Board, Processor, and Port.",
          "Sketch Name, Programmer, and Baud Rate.",
          "Board, COM Port, and CPU Speed.",
          "File, Programmer, and Library."
        ],
        "answer_index": 0,
        "explanation": "You must select the correct Board (Arduino Mega or Mega 2560), the Processor (ATmega2560), and the Port (the COM port assigned to the board)."
      },
      {
        "chapter": "Chapter 1",
        "question": "What is the purpose of the 'Serial Monitor' in the Arduino IDE?",
        "options": [
          "To monitor the voltage levels of the pins.",
          "To display text sent from the Arduino and send text to the Arduino.",
          "To compile the sketch and show errors.",
          "To check for ESD damage."
        ],
        "answer_index": 1,
        "explanation": "The Serial Monitor is a utility that can display text sent from the Arduino board and can also be used to send text back to the board, all over the USB link."
      },
      {
        "chapter": "Chapter 2",
        "question": "What is the full part number of the 8-bit AVR microcontroller used on the Arduino MEGA 2560?",
        "options": [
          "ATmega328P-PU",
          "ATmega2560-16AU",
          "ATmega16U2",
          "ATmega2560-15AU"
        ],
        "answer_index": 1,
        "explanation": "The main microcontroller is an ATmega2560 8-bit AVR from Microchip with the full part number ATmega2560-16AU."
      },
      {
        "chapter": "Chapter 2",
        "question": "How much Flash (program) memory does the Arduino MEGA 2560 have compared to the Arduino Uno?",
        "options": [
          "64K bytes (2 times the Uno)",
          "128K bytes (4 times the Uno)",
          "256K bytes (8 times the Uno)",
          "32K bytes (Same as the Uno)"
        ],
        "answer_index": 2,
        "explanation": "The Arduino MEGA 2560 (ATmega2560) has 256K bytes of Flash memory, which is 8 times the 32K bytes found on the Arduino Uno (ATmega328P)."
      },
      {
        "chapter": "Chapter 2",
        "question": "How much SRAM (data) memory does the Arduino MEGA 2560 have?",
        "options": [
          "2K bytes",
          "4K bytes",
          "8K bytes",
          "256K bytes"
        ],
        "answer_index": 2,
        "explanation": "The Arduino MEGA 2560 has 8K bytes of SRAM, which is 4 times the 2K bytes found on the Arduino Uno."
      },
      {
        "chapter": "Chapter 2",
        "question": "What happens to the data stored in SRAM when the Arduino is powered off?",
        "options": [
          "It is saved to the EEPROM.",
          "It is lost.",
          "It is retained for 100 years.",
          "It is transferred to the bootloader."
        ],
        "answer_index": 1,
        "explanation": "SRAM (Static Random Access Memory) is volatile memory. This means it loses its contents when its power is switched off."
      },
      {
        "chapter": "Chapter 2",
        "question": "What is the Flash memory on the Arduino MEGA 2560 primarily used for?",
        "options": [
          "Storing variables used during runtime.",
          "Storing the Arduino sketch (program instructions).",
          "Storing data that must be saved when power is off.",
          "Buffering USB data."
        ],
        "answer_index": 1,
        "explanation": "Flash memory is non-volatile memory used to store the program instructions of an Arduino sketch. When a sketch is uploaded, it is loaded into this Flash memory."
      },
      {
        "chapter": "Chapter 2",
        "question": "Which type of memory is non-volatile and designed for user data storage that persists after power is turned off?",
        "options": [
          "SRAM",
          "Flash",
          "EEPROM",
          "ICSP Memory"
        ],
        "answer_index": 2,
        "explanation": "EEPROM (Electrically Erasable Programmable Read Only Memory) is non-volatile memory used for data storage. Data stored in EEPROM will not be lost if power to the Arduino is switched off."
      },
      {
        "chapter": "Chapter 2",
        "question": "Which type of memory on the ATmega2560 has a *longer* lifespan in terms of Write/Erase cycles?",
        "options": [
          "Flash (10,000 cycles)",
          "EEPROM (100,000 cycles)",
          "SRAM (unlimited write cycles, but volatile)",
          "All memory types have the same 10,000 cycle limit."
        ],
        "answer_index": 1,
        "explanation": "The Flash program memory has a life of 10,000 Write/Erase cycles, while the EEPROM data memory has a lifetime of 100,000 Write/Erase cycles."
      },
      {
        "chapter": "Chapter 2",
        "question": "SD cards and micro SD cards interface with the Arduino MEGA 2560 using which communication bus?",
        "options": [
          "The TWI (I2C) bus",
          "The SPI bus",
          "A parallel bus",
          "The UART bus"
        ],
        "answer_index": 1,
        "explanation": "SD cards interface to the SPI (Serial Peripheral Interface) bus pins of an Arduino."
      },
      {
        "chapter": "Chapter 2",
        "question": "Why might a small (Uno form-factor) shield that uses the SPI bus *not* work on an Arduino MEGA 2560?",
        "options": [
          "The MEGA 2560 does not support SPI.",
          "The SPI pins on the MEGA 2560 are on digital pins 50-53, which do not align with the Uno's SPI pins (10-13).",
          "The MEGA 2560 operates at 3.3V, and the Uno shield is 5V.",
          "The MEGA 2560 requires a special 'SPI enable' sketch."
        ],
        "answer_index": 1,
        "explanation": "The SPI bus pins are on digital pins 10-13 on an Uno, but on digital pins 50-53 on a MEGA 2560. A small shield will only work if it connects to the 6-pin ICSP header, where the SPI pins are mirrored on both boards."
      },
      {
        "chapter": "Chapter 2",
        "question": "The TWI (Two Wire Interface) on the Arduino is compatible with what other common serial protocol?",
        "options": [
          "SPI",
          "RS-232",
          "I2C",
          "CAN Bus"
        ],
        "answer_index": 2,
        "explanation": "TWI is compatible with the I²C (Inter-Integrated Circuit) serial protocol, so I²C memory chips and devices will also work with the Arduino MEGA 2560 using the Wire library."
      },
      {
        "chapter": "Chapter 2",
        "question": "If you supply 9V to the external power jack, what voltage would you expect to measure on the 'Vin' pin?",
        "options": [
          "Exactly 9V",
          "5V",
          "Slightly less than 9V (due to a diode voltage drop).",
          "12V"
        ],
        "answer_index": 2,
        "explanation": "The Vin pin is connected to the external power jack, but *after* a reverse polarity protection diode. This diode causes a voltage drop of approximately 0.7V to 0.8V."
      },
      {
        "chapter": "Chapter 2",
        "question": "What is the main operating voltage of the Arduino MEGA 2560's internal circuitry and I/O pins?",
        "options": [
          "3.3V",
          "5V",
          "12V",
          "16V"
        ],
        "answer_index": 1,
        "explanation": "The Arduino MEGA 2560 is considered a 5V device. The main microcontroller and the input/output (I/O) pins operate at 5V levels."
      },
      {
        "chapter": "Chapter 2",
        "question": "At what clock frequency does the main ATmega2560 microcontroller run?",
        "options": [
          "8MHz",
          "12MHz",
          "16MHz",
          "100MHz"
        ],
        "answer_index": 2,
        "explanation": "The main microcontroller (ATmega2560) runs at a frequency of 16MHz, provided by a 16MHz ceramic resonator."
      },
      {
        "chapter": "Chapter 2",
        "question": "On revision 3 boards, why does switching the 'L' LED on draw virtually no current from the digital pin 13 itself?",
        "options": [
          "The LED has a very high internal resistance.",
          "The LED is buffered through a unity gain op-amp.",
          "The 'L' LED is connected to the Vin pin, not a digital pin.",
          "The ATmega2560 does not supply current, only voltage."
        ],
        "answer_index": 1,
        "explanation": "On R3 boards, the L LED is buffered by a unity gain op-amp circuit. Pin 13 just supplies a signal to the op-amp, and the op-amp supplies the current to the LED."
      },
      {
        "chapter": "Chapter 2",
        "question": "What is the recommended *maximum* output current that can be supplied by the 3.3V pin on an Arduino MEGA 2560 (R3)?",
        "options": [
          "50mA",
          "150mA",
          "800mA",
          "1.0A"
        ],
        "answer_index": 1,
        "explanation": "The 3.3V regulator on the R3 board can supply a recommended maximum output current of 150mA. (Note: Older boards or incorrect documentation may state 50mA)."
      },
      {
        "chapter": "Chapter 2",
        "question": "What is the purpose of the IOREF pin, which was added in revision 3 boards?",
        "options": [
          "It is a reset pin for I/O operations.",
          "It provides a reference voltage (5V on a MEGA) for shields to adapt their logic levels.",
          "It is a secondary 3.3V power pin.",
          "It is an unconnected pin reserved for future use."
        ],
        "answer_index": 1,
        "explanation": "The IOREF pin provides the operating voltage of the board (5V on a MEGA 2560). This is intended as a reference for shields so they can determine the board's voltage and enable level shifters if needed."
      },
      {
        "chapter": "Chapter 2",
        "question": "How many digital pins (numbered 0 to 53) are there on the Arduino MEGA 2560?",
        "options": [
          "53",
          "54",
          "16",
          "100"
        ],
        "answer_index": 1,
        "explanation": "The digital pins are numbered from 0 to 53. Because the numbering starts at 0, this means there are 54 total digital pins."
      },
      {
        "chapter": "Chapter 2",
        "question": "What is the *absolute maximum total current* that can be drawn by the entire ATmega2560 microcontroller (sum of all pins)?",
        "options": [
          "40mA",
          "200mA",
          "1080mA (1.08A)",
          "800mA"
        ],
        "answer_index": 1,
        "explanation": "While an individual pin might handle 20mA, there is an absolute maximum total current of 200mA that can be drawn by the ATmega2560 microcontroller. Exceeding this limit can destroy the chip."
      },
      {
        "chapter": "Chapter 2",
        "question": "How do you configure a digital pin as an input *with* the internal pull-up resistor enabled?",
        "options": [
          "pinMode(pin, INPUT);",
          "pinMode(pin, OUTPUT);",
          "pinMode(pin, INPUT_PULLUP);",
          "digitalWrite(pin, HIGH);"
        ],
        "answer_index": 2,
        "explanation": "The internal pull-up resistor (20kΩ-50kΩ) can be enabled on a pin by passing `INPUT_PULLUP` to the `pinMode()` function. Using just `INPUT` configures it as an input without the pull-up."
      },
      {
        "chapter": "Chapter 2",
        "question": "Which function is used in an Arduino sketch to output a PWM (Pulse Width Modulation) signal?",
        "options": [
          "digitalWrite()",
          "pwmWrite()",
          "analogRead()",
          "analogWrite()"
        ],
        "answer_index": 3,
        "explanation": "In an Arduino sketch, the `analogWrite()` function is used to control the duty cycle of PWM pins. The value is set between 0 (0% duty cycle / off) and 255 (100% duty cycle / on)."
      }
    ]
    }
}